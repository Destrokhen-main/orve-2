## Компоненты.

Единицой приложения в orve, является компонент.

Компонент, это функция. Вы можете использовать стрелочную функцию, но лучше использовать обычную.

При использование стрелочной функции теряется контекст, что будет мешать работе с контекстом. Но если вы уверены, что вам не нужен контекст в компоненте. То вы можете спокойно использовать стрелочную функцию.

*Пожалуйста не забывайте называть компоненты, это облегчит вам дебаг приложения*

Пример компонента:
```
function App(props) {
  return (
    ...jsx
  )
}
```

### context

Для удобной работы с контекстом, обращайтесь к `this` в функции.

`this` - хранит объект context

Стоит заметить, что вы спокойно можете мутировать контекст, если вам это будет необходимо.

Все компоненты, который находяться ниже мутированного контекста получат мутированный контекст. Таким образом можно прокидывать различную информацию.


### props

Это объект который приходит от родителя компонента, данный компонент хранит в себе атрибуты компонента.

```
<Component id="1" name={"asd"} .... >
  |
function Component({ id, name })
```

Если компонент такого вида:

```
<Component>
  ....
</Component>
```

То в props добавиться массив `children`

Чтобы использовать его, можно просто указать

```
function Component({ children }) {
  return (
    <div>
      {children} --> 'array" - В таком случаи парсер сам развернёт массив.
    </div>
  )
}
```

В отличие от React, у вас есть возможность спокойно писать class внутри компонентов.

Если парсер понимает, что класс прокидывается как пропс, он добавит к нему символ `o` - в таком случаи:

```
<Component `class="123"`> ==== { oclass: "123" }
```

Вам нет необходимости убирать `o` чтобы использовать oclass в качестве класса компонента.

Парсер сам уберёт o

Пример:
```
function Component({children, ...props}) {
  return (
    <div {...props}>{children}</div>
  )
} 

// Этот компонент главнй
function App() {
  return (
    <div>
      <Component class="123" />
    </div>
  )
}
```

По итогу в document будет:
```
<div id="app">
  <div>
    <div class="123">
    </div>
  </div>
</div>
``` 

#### Цикл компонентов.

Иногда есть необходимость переиспользовать компонент несколько раз внутри этого же компонента.

```
function Comment({ i }) {
  if (i === 100) return (<div>End</div>)

  return (
    <div>
      <div>Author: "{i}"</div>
      <Comment name={i + 1} />
    </div>
  )
}
```

Хоть парсер и написан так, чтобы не создать рекурсию в таких случаях, но всё равно может быть ситуации, когда в консоле будет выпадать ворнинг

`RangeError: Maximum call stack size exceeded`

В таком случаи приложение отработает до сломанного компонента и не будет дальше собираться.

На данный момент парсер и маунтер работают до 1280 вложенных компонентов.

#### Slot

Иногда при разработке компонентов, есть потребность использовать Slot

```
function Modal() {
  return (
    <div class="wrapper">
      <div class="modal>
        <div>
          // HEADER 
        </div>
        <div>
          // Body
        </div>
        <div>
          // Footer
        </div>
      </div>
    </div>
  )
}
```

В таком случаи трудно распределить куски кода по секциям.

У вас есть несколько способов решения данной проблемы. Например прокидывать пропсами куски jsx и вставлять их. Такой способ будет работать, но он начинает мешать jsx вместе с кодом.

Если вы привыкли так решать данную задачу, вы также сможете решить её тут.

В противном случаи у вас есть возможность использовать Fragment.

Для этого в компоненте необходимо указать вот такие конструкции.

```
function App() {
  return (
    <Modal>
      <Fragment name="header">...</Fragment>
      <Fragment name="body">...</Fragment>
      <Fragment name="footer">...</Fragment>
    </Modal>
  )
}
```

В случаи если name не указать, код внутри `Fragment` будет считаться default Fragment внутри компонента

*Обратите внимание, slot можно использовать только в компонентах*

Данные slot буду объявлены в props

```
function Modal({ $slot }) {
  return (
    <div class="wrapper">
      <div class="modal>
        <div>
          {$slot.header}
        </div>
        <div>
          {$slot.body}
        </div>
        <div>
          {$slot.footer}
        </div>
      </div>
    </div>
  )
}
```

В таком случаи slot будут работать

Если есть необходимость задать значение по умолчанию:
Тогда вы можете использовать "??":

```
{ $slot.header ?? <...jsx> }
```

#### Типизация пропсов.

Внутри компонента есть возможно объявить валидацию props.

Чтобы это сделать необходимо указать у компонента свойство props

```
function App() {
  return (
    <div>
      ...
    </div>
  )
}

App.props = {
  ...
}
```

объект props представляет собой входящие props комопнента.

Нет необходимости описывать все пропсы.
Используйте только для тех, которых вам действительно важны.

Объект состоит из ключа props и инструкции

Например, вы хотите сделать так, чтобы атрибут key для компнента выше принимал только String.

Для этого в props укажите
```
App.props = {
  key: {
    type: String
  }
}
```

В данном случаи, если в key будет отправлено значение, которое не удовлетворяет типу, в итоговый props с key ничего не попадёт.

В данном случаи легче ничего не отправлять чем указывать какое-то значение по умолчанию.

Если вы хотите сообщать пользователю, что данный prop необходим, укажите свойство

```
App.props = {
  key: {
    type: String,
    required: true
  }
}
```

В таком случаи, компонент будет отрисовываться, но в консоле будет ошибка. Вместо значения, ничего не будет отображаться.

Если вы хотите указать значение по умолчанию, тогда вам достаточно указать  свойство `default`

Данное свойство будет вставлять значени по умолчанию, если какое-то условие не было выполнено.
```
App.props = {
  key: {
    type: String,
    required: true,
    default: "test"
  }
}
```

Данное свойствой принимает значениe или функцию.

Например для того, чтобы задать [] или {} лучше это делать так

```
default: () => []
default: () => ({})
```

Чтобы перестраховываться, пожалуйста прокидывайте все необходимые свойства, а именно type, default, required.

Если есть необходимость прокидывать несколько типов, допустим, в key теперь надо отправлять или String или Number.

Для этого, достачно указать тип в массиве.

```
App.props = {
  key: {
    type: [String, Number],
    required: true,
    default: "test"
  }
}
```

В таком случаи проверка будет проходить по 2 типам.

#### HTML in jsx

Вы можете использовать HTML внутри компонентов.

```
function App() {
  return (
    <div>
      { `<div>....</div>` }
    </div>
  )
}
```

Обратите внимание, чтобы у кода всегда был родительский элемент, это необходимо, чтобы парсер правильно обработал код.

### o-hooks, o-key, o-ref

Помимо обычных атрибутов, есть специальные, которые нужно заполнять по правилам.

#### o-hooks

Это объект представляющий собой совокупность функций жизненого цикла компонента.

На данный момент есть такие функции
```
{
  beforeCreate(),
  created(),
  beforeMount(),
  mounted(),
  beforeUpdate(),
  updated(),
  beforeUnmount(),
  unmounted(),
}
```

На данный момент работают все, кроме beforeUpdate, updated.

Данные функции ничего не принимают, могут быть асинхронными.

Когда компонент подойдёт к определенной стадии жизненого цикла, будет вызвана необходимая функция.

```
function App() {
  return (
    <div o-hooks={{ created() { ... } }}></div>
  )
}
```

#### o-key
В данном аттрибуте нет необходимости, если вы не используете его вместе с `ref.for()`. Данный проп просто перезапишет ключ компонента.

#### o-ref
Это специальная свойство, которое хранит в себе реактивную ссылку на элемент `refL()`


### Event

Для того, чтобы привязать слушатель события необходимо написать в аттрибутах

on<Название события> --- onInput, onClick, onChange. 

*Вы можете писать как onInput, так и oninput*

слушатель события отработает как нужно.

```
function App() {
  return (
    <div onClick={(event) => {....}} ></div>
  )
}
```

*Вы также можете прокидывать несколько обработчиков*