# o-for

Чтобы вывести массив, используйте `o-for`

Заметим сразу, o-for это обертка и не отображается внутри приложения. Из-за этого пока есть некоторые особенности. Для `o-for` необходим родительский компонент

пример

```javascript
function App() {

  const arr = ref([1,2,3])

  return (
    <div>
      <o-for items={arr}>
        {
          (item, index) => (
            <div>{item}</div>
          ) 
        }
      </o-for>
    </div>
  )
}
```

Можно не указывать o-key, если список простой. Если вы понимаете, что в компоненте возможна сложная логика, можете указать в родителе `o-key`

Если у вас список такого вида

```javascript
const a = ref([[1],[2],[3]])
```

Нет необходимости внутри компонента расписывать ещё один `o-for`

```javascript
function App() {
  return (
    <div>
      <o-for>
        {
          (item) => (
            <div>
              {item.map((e) => <span>{e}</span>)}
            </div>
          ) 
        }
      </o-for>
    
    </div>
  )
}
```

Такой код, покроет необходимое отображение. А то, что будет реактивно меняться внутри, уже займётся библиотека.


Вы можете отдать o-for

```
* Array
* Object
* Number
```

Если вам нужно один раз отрисовать список, можете отдавать не реактивный куски переменные, если нужно следить за изменением, используйте
```
ref | computed | computedEffect
```