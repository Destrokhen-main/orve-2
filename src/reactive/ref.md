### Реактивность

Как же добиться реактивности в данной библиотеки.

Для начала давайте решим просто пример реактивности.

Говоря об реактивности, приводят 1 известный пример

```
a = 1;
b = 2;
c = a + b // 3

a += 1;
log(c) // должно быть равно 4 
```

Как достичь такого результата при использование orve?

Изначально нужно понимать, что реактивная переменная в orve это не привязанная ни к чему переменная. Это значит что вы можете создавать и использовать переменные где угодно

Теперь вернёмся к примеру

для того, чтобы объявить реактивную переменную, достаточно вызвать функцию `ref` - схожа с функцией ref в vue 3

данная функция обернёт вашу переменную в необходимый кусок кода, чтобы коду дальше было проще с ней общаться

```
const a = 1; // 1

const r = ref(a) // { value: 1, .... }
```

Теперь чтобы поменять переменную или вызвать её, необходимо обратиться в .value

```
// ДО
let a = 1;
a++;

// После
const a = ref(1);
a.value++;
```

В ref можно поместить `String`, `Number`, `Boolean`, `Array`, `Object`

Если говорить о примитивах, то тут всё довольно одинаково

О остальных типах данных вы сможете почитать ниже или в собственном разделе.

Отлично, создавать реактивную переменную мы научились. Как ей теперь пользоваться

Чтобы создавать специальные выражения из реактивных переменных необходимо использовать функцию `computed`

Данная функция принимает стрелочную функцию и вторым аргументом все зависимости об этом чуть позже

Теперь наш пример будет выглядеть вот так

```
const a = ref(1);
const b = ref(2);
const c = computed(() => a.value + b.value, [a,b])
```

Теперь в c будет лежать всегда правильно актуальная информация. При изменение или а или b стрелочная функция будет вызвана повторно.

Чтобы вам не следить за каждой зависимостью в computed, вы можете использовать плагин для babel `babel-orve-plugin`

Данный плагин за вас расставит все зависимости которые встретил в computed

Будьте внимательны, если вы вторым аргументом сами проставите массив, то плагин данную функцию обходить не будет. Это сделано специально, чтобы пользователи, которые сами хотят выставить зависимости, смогли это сделать

Также, не откидывайте логику с computed по отдельным функциям
```

const a = ref(1);

function A() {
  return a.value
}

function App() {
  const c = computed(() => A());
  return <div>{c}</div>
}
```

В таком случи плагин не сможет определить, какие переменные необходимо указать в зависимостях. Решить проблему поможет, только указывание переменных самостоятельно

```
// GOOD
const a = ref(1);

function A() {
  return a.value
}

function App() {
  const c = computed(() => A(), [a]);
  return <div>{c}</div>
}
```

